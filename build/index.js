class w{disposables;own(H){if(!this.disposables)this.disposables=new Set;return this.disposables.add(H),H}destroy(){this.disposables?.forEach((H)=>H.destroy())}}var C=function(H,W,j){function J(Z,K){function $(_){return _===H?.VERTEX_SHADER?"vertex":_===H?.FRAGMENT_SHADER?"fragment":void 0}if(K!==H.VERTEX_SHADER&&K!==H.FRAGMENT_SHADER)throw new Error(`Shader error in ${$(K)}`);const Q=H.createShader(K);if(!Q)throw new Error(`Unable to generate ${$(K)} shader.`);if(H.shaderSource(Q,Z),H.compileShader(Q),!H.getShaderParameter(Q,H.COMPILE_STATUS))console.error(`Shader compile error in ${$(K)}:`+H.getShaderInfoLog(Q));return Q}const k=H.createProgram();if(!k)throw new Error("Unable to create program.");const q=J(W,H.VERTEX_SHADER),Y=J(j,H.FRAGMENT_SHADER);if(H.attachShader(k,q),H.attachShader(k,Y),H.linkProgram(k),H.detachShader(k,q),H.detachShader(k,Y),H.deleteShader(q),H.deleteShader(Y),H.validateProgram(k),!H.getProgramParameter(k,H.LINK_STATUS))throw new Error("Unable to initialize the shader program:\n"+H.getProgramInfoLog(k));return k},B=function(H,W){H.deleteProgram(W)};class F extends w{gl;program;constructor(H,W,j){super();this.gl=H,this.program=C(H,W.trim(),j.trim())}use(){this.gl.useProgram(this.program)}destroy(){super.destroy(),B(this.gl,this.program)}}class M extends w{activeProgramId="";gl;programs={};constructor(H){super();this.gl=H}addProgram(H,W,j){if(this.programs[H])this.removeProgram(H);this.programs[H]=this.own(new F(this.gl,W,j))}useProgram(H){if(this.activeProgramId!==H)this.activeProgramId=H,this.programs[H].use()}removeProgram(H){this.programs[H].destroy(),delete this.programs[H]}getProgram(H){return this.programs[H??this.activeProgramId]}}class X extends w{gl;triangleArray;constructor(H){super();this.gl=H,this.triangleArray=H.createVertexArray(),H.bindVertexArray(this.triangleArray)}destroy(){this.gl.deleteVertexArray(this.triangleArray)}}class z extends w{bufferRecord={};lastBoundBuffer;gl;programs;constructor(H,W){super();this.gl=H,this.programs=W}getAttributeLocation(H,W){const j=this.programs.getProgram(W)?.program;return j?this.gl.getAttribLocation(j,H)??-1:-1}createBuffer(H){this.deleteBuffer(H);const W=this.gl?.createBuffer();if(!W)throw new Error(`Unable to create buffer "${H}"`);const j={buffer:W,location:this.getAttributeLocation(H)};return this.bufferRecord[H]=j,j}deleteBuffer(H){if(this.bufferRecord[H])this.gl.deleteBuffer(this.bufferRecord[H].buffer),delete this.bufferRecord[H]}getAttributeBuffer(H,W){const j=this.bufferRecord[H];if(!j){if(W)return this.createBuffer(H);throw new Error(`Attribute "${H}" not created. Make sure "createBuffer" is called.`)}return j}bufferData(H,W,j,J,k){const q=this.getAttributeBuffer(W);if(j)this.gl.bufferData(H,j,k);else this.gl.bufferData(H,J,k);q.bufferSize=J,q.bufferArray=j??new Float32Array(q.bufferSize/Float32Array.BYTES_PER_ELEMENT).fill(0),q.usage=k,q.target=H}bufferSubData(H,W,j,J,k){if(J)this.gl.bufferSubData(H,j,W,J,k);else this.gl.bufferSubData(H,j,W)}bindBuffer(H,W){if(this.lastBoundBuffer!==W)this.lastBoundBuffer=W,this.gl.bindBuffer(H,W.buffer)}destroy(){Object.keys(this.bufferRecord).forEach((H)=>this.deleteBuffer(H))}}class V extends w{gl;programs;constructor(H,W){super();this.gl=H,this.programs=W}getUniformLocation(H,W){const j=this.programs.getProgram(W)?.program;return j?this.gl.getUniformLocation(j,H)??void 0:void 0}}var R="position";var G=function(H){return new Proxy(H,{get(j,J){const k=j,q=k[J];if(typeof q==="function")return(...Z)=>{const K=q.apply(k,Z);return console.log(`gl.${String(J)}(`,Z,") = ",K),K};else return console.log(`gl.${String(J)} = `,q),q}})},N={alpha:!0,antialias:!1,depth:!0,desynchronized:!0,failIfMajorPerformanceCaveat:void 0,powerPreference:"default",premultipliedAlpha:!0,preserveDrawingBuffer:!1,stencil:!1},T=1e4;class E extends w{gl;programs;attributeBuffers;uniforms;constructor(H,W){super();this.gl=G(H.getContext("webgl2",{...N,...W})),this.programs=this.own(new M(this.gl)),this.attributeBuffers=this.own(new z(this.gl,this.programs)),this.uniforms=this.own(new V(this.gl,this.programs))}initialize(){this.gl.viewport(0,0,this.gl.drawingBufferWidth,this.gl.drawingBufferHeight),this.attributeBuffers.createBuffer(R);const H=this.attributeBuffers.getAttributeBuffer(R);this.attributeBuffers.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER,H),this.gl.vertexAttribPointer(H.location,3,WebGL2RenderingContext.FLOAT,!1,0,0),this.gl.enableVertexAttribArray(H.location),this.attributeBuffers.bufferData(WebGL2RenderingContext.ARRAY_BUFFER,R,void 0,9*T*Float32Array.BYTES_PER_ELEMENT,WebGL2RenderingContext.STATIC_DRAW)}updateTrianglePosition(H,W){const j=this.attributeBuffers.getAttributeBuffer(R);this.attributeBuffers.bindBuffer(WebGL2RenderingContext.ARRAY_BUFFER,j),this.attributeBuffers.bufferSubData(WebGL2RenderingContext.ARRAY_BUFFER,Float32Array.from(W),H*3*3*Float32Array.BYTES_PER_ELEMENT)}draw(H){this.gl.clear(WebGL2RenderingContext.COLOR_BUFFER_BIT),this.gl.drawArrays(WebGL2RenderingContext.TRIANGLES,0,H)}bindVertexArray(){this.own(new X(this.gl))}}function f(){console.log("Hello World!")}function l(H){const W=new E(H);return W.programs.addProgram("test",`
            #version 300 es

            precision highp float;
            
            layout (location=0) in vec4 position;
            
            void main() {
                gl_Position = position;
            }
        `,`
            #version 300 es

            precision highp float;
            out vec4 fragColor;
            
            void main() {
                fragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }        
        `),W.programs.useProgram("test"),W.initialize(),W.updateTrianglePosition(0,[0,0.5,0,-0.5,-0.5,0,0.5,-0.5,0]),W.draw(3),W}export{l as testCanvas,f as hello};

//# debugId=C829DE9ACC91A9F564756e2164756e21
